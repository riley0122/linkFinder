<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Link Finder</title>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
        }
      }
    </script>

    <style>
      body {
        background-color: black;
        color: green;
      }

      .hidden {
        display: none;
      }

      .context-menu {
        position: absolute;
        background-color: white;
        border: 1px solid black;
        padding: 5px;
        list-style-type: none;
        margin: 0;
        display: none;
      }

      .context-menu li {
        cursor: pointer;
        margin: 5px 0;
      }

      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
    <noscript>
      Sorry but this web page will not work without JavaScript.
    </noscript>

    <div id="app" class="hidden"></div>

    <script type="module">
      let randomness = 150;
      import { createApp, ref } from "vue";

      class Circle {
        constructor(x, y, radius, ctx, id, link) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.ctx = ctx;
          this.colour = "green";
          this.id = id;
          this.links = [];
          this.link = link;
        }

        addLink(link, circles) {
          for (const circle of circles) {
            if (circle.link == link) {
              this.addLinkById(circle.id);
              return;
            }
          }
          this.links.push(circles.length);
          circles.push(
            new Circle(
              this.x + Math.random() * randomness - randomness / 2,
              this.y + Math.random() * randomness - randomness / 2,
              1,
              this.ctx,
              circles.length,
              link
            )
          );
        }

        addLinkById(id) {
          this.links.push(id);
        }

        changeColour(colour) {
          this.colour = colour;
        }

        draw(circles) {
          let counter = 0;
          for (const c in circles) {
            if (circles[c].links.includes(this.id)) {
              counter++;
              this.ctx.beginPath();
              this.ctx.moveTo(this.x, this.y);
              this.ctx.lineTo(circles[c].x, circles[c].y);
              this.ctx.strokeStyle = "white";
              this.ctx.stroke();
            }
          }
          this.radius = Math.min(counter * 3 + 5, 35);
          this.ctx.beginPath();
          this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          this.ctx.fillStyle = this.colour;
          this.ctx.fill();
          this.ctx.closePath();
        }

        updatePosition(circles) {
          const force = { x: 0, y: 0 };

          for (const c of circles) {
            if (c.id !== this.id) {
              const dx = c.x - this.x;
              const dy = c.y - this.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              // Adjust force based on link strength
              if (this.links.includes(c.id)) {
                force.x += dx * 0.01;
                force.y += dy * 0.01;
              }

              // Adjust force based on repulsion
              const repulsion = 100 / (distance * distance);
              force.x -= repulsion * (dx / distance);
              force.y -= repulsion * (dy / distance);
            }
          }

          // Update circle position based on force
          this.x += force.x;
          this.y += force.y;

          // Limit circle position within the canvas bounds
          this.x = Math.max(
            this.radius,
            Math.min(window.innerWidth - this.radius, this.x)
          );
          this.y = Math.max(
            this.radius,
            Math.min(window.innerHeight - this.radius, this.y)
          );
        }
      }

      document.getElementById("app").classList.remove("hidden");

      createApp({
        setup() {
          const canvas = document.createElement("canvas");
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          document.getElementById("app").appendChild(canvas);

          randomness = (window.innerWidth / 3 + window.innerHeight / 3) / 2;

          const ctx = canvas.getContext("2d");

          const circles = [
            new Circle(
              canvas.width / 2,
              canvas.height / 2,
              30,
              ctx,
              0,
              "https://google.com"
            ),
            new Circle(
              canvas.width / 2.2,
              canvas.height / 1.2,
              30,
              ctx,
              1,
              "https://apple.com"
            ),
            new Circle(
              canvas.width / 3,
              canvas.height / 3,
              30,
              ctx,
              2,
              "https://lucasammer.com"
            ),
          ];

          circles[2].addLink("https://google.com", circles);
          circles[1].addLinkById(0);

          let CurrentLink = "None";

          // Context menu
          const contextMenu = document.createElement("ul");
          contextMenu.classList.add("context-menu");
          const RenderContextMenu = () => {
            contextMenu.innerHTML = `
            <li id="link"><b>${CurrentLink}</b></li>
            <li id="delete">Delete</li>
            <li id="scan">Scan</li>
          `;
          };
          RenderContextMenu();
          document.body.appendChild(contextMenu);

          // Event listeners for dragging
          let isDragging = false;
          let selectedCircle = null;
          let isContexting = false;

          canvas.addEventListener("mousedown", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check if the mouse is inside any circle
            for (const circle of circles) {
              const distance = Math.sqrt(
                (mouseX - circle.x) ** 2 + (mouseY - circle.y) ** 2
              );
              if (distance <= circle.radius) {
                isDragging = true;
                selectedCircle = circle;
                break;
              } else {
                if (isContexting) {
                  contextMenu.display = "None";
                }
              }
            }
          });

          canvas.addEventListener("mousemove", (e) => {
            if (isDragging && selectedCircle) {
              // User is dragging, set the circle position directly
              const rect = canvas.getBoundingClientRect();
              selectedCircle.x = e.clientX - rect.left;
              selectedCircle.y = e.clientY - rect.top;
            } else {
              // User is not dragging, update positions based on forces
              for (const circle of circles) {
                circle.updatePosition(circles);
              }
            }

            redrawCanvas();
          });

          canvas.addEventListener("mouseup", () => {
            isDragging = false;
            selectedCircle = null;
          });

          let currentCircleContext = null;

          // Event listener for creating a new circle on right-click
          canvas.addEventListener("contextmenu", (e) => {
            isDragging = false;
            isContexting = true;

            e.preventDefault(); // Prevent the default context menu

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let clickedExistingCircle = false;

            // Check if the mouse is inside any circle
            for (const circle of circles) {
              const distance = Math.sqrt(
                (mouseX - circle.x) ** 2 + (mouseY - circle.y) ** 2
              );
              if (distance <= circle.radius) {
                clickedExistingCircle = true;
                CurrentLink = circle.link;
                RenderContextMenu();
                currentCircleContext = circle.id;
                displayContextMenu(e.clientX, e.clientY, circle);
                break;
              }
            }

            if (!clickedExistingCircle) {
              let name = prompt("Enter the link for the new node:");
              if (name == null || name.trim() == "") {
                return;
              }
              // Create a new circle at the right-click position
              circles.push(
                new Circle(mouseX, mouseY, 30, ctx, circles.length, name)
              );

              // Redraw the canvas with the new circle
              redrawCanvas();
            }
          });

          // Function to redraw the canvas with all circles
          const redrawCanvas = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update positions based on forces
            for (const circle of circles) {
              circle.updatePosition(circles);
            }

            // Draw circles based on updated positions
            for (const circle of circles) {
              circle.draw(circles);
            }
          };

          // Function to display context menu
          const displayContextMenu = (x, y, circle) => {
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.display = "block";

            // Event listener for context menu items
            contextMenu.addEventListener("click", (e) => {
              if (currentCircleContext !== circle.id) {
                return;
              }
              if (e.target.id === "delete") {
                // Delete the selected circle
                const index = circles.indexOf(circle);
                if (index !== -1) {
                  circles.splice(index, 1);
                  redrawCanvas();
                }
              } else if (e.target.id === "scan") {
                const evtSource = new EventSource(
                  `http://localhost:3000/scan/${encodeURIComponent(
                    circle.link
                  )}`
                );
                circle.changeColour("yellow");
                redrawCanvas();
                evtSource.onmessage = (event) => {
                  console.log(JSON.parse(event.data));
                  if (JSON.parse(event.data).name == "finished") {
                    circle.changeColour("orange");
                    redrawCanvas();
                    evtSource.close();

                    circle.changeColour("blue");
                    redrawCanvas();
                  } else if (JSON.parse(event.data).name == "error") {
                    circle.changeColour("red");
                    redrawCanvas();
                    evtSource.close();
                  } else if (JSON.parse(event.data).name == "url") {
                    circle.addLink(JSON.parse(event.data).data, circles);
                  }
                };
              }

              isContexting = false;
              // Hide the context menu
              contextMenu.style.display = "none";
            });
          };

          // Initial draw
          redrawCanvas();
        },
      }).mount("#app");
    </script>
  </body>
</html>
